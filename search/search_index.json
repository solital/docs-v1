{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Solital Framework documentation You are reading the version documentation: 1.x License Solital uses MIT license by default Please read the Starting page to start using Solital","title":"Welcome"},{"location":"#welcome-to-solital-framework-documentation","text":"You are reading the version documentation: 1.x License Solital uses MIT license by default Please read the Starting page to start using Solital","title":"Welcome to Solital Framework documentation"},{"location":"auth/","text":"Authenticate Solital uses the Guardian class to perform authentication. First of all, make sure to change the Guardian constants in config.php inside the config folder. /** * GUARDIAN CONSTANTS */ /* Login route if login verification is false */ define('URL_LOGIN', 'your_login_url'); /* Dashboard route if login verification is true */ define('URL_DASHBOARD', 'your_dashboard_url'); /* Standard Guardian index */ define('INDEX_LOGIN', 'solital_index_login'); Setting On your Controller, extend the AuthController class. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Controller\\Auth\\AuthController; class UserController extends AuthController { #... } To do this, define your database username and password fields, the values \u200b\u200bof your form input and the table where your username and password will be stored as shown below. $res = $this->columns('your_username_column', 'your_password_column') ->values('input_username_name', 'input_password_name') ->register('your_table'); The $res variable will return true if authentication is true. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { Message::newMessage('wrongLogin', 'Incorrect username or password'); response()->redirect('your_login_url'); } Below is an example method of authentication. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Controller\\Auth\\AuthController; class UserController extends AuthController { public function verifyLogin() { $res = $this->columns('email_column', 'pass_column') ->values('input_email', 'input_password') ->register('tb_users'); if ($res == false) { Message::newMessage('wrongLogin', 'Incorrect username or password'); response()->redirect('your_login_url'); } } } Check login To ensure that the user is authenticated, use checkLogin() method. If the login has not been validated using the validate() method, the user will be redirected to the route defined in the constant URL_LOGIN . The example below shows the method along with the Wolf template. Guardian::checkLogin(); Wolf::loadView('home'); To ensure that the user doesn't fall into the login route when it has already been validated, insert the checkLogged() method in your login route. This method will redirect the user to your system's dashboard. Make sure your constant URL_DASHBOARD has a defined value. Guardian::checkLogged(); Wolf::loadView('login'); Log off To log off, use the logoff() method. Guardian::logoff(); Login structure and password recovery See here how to create a pre-assembled login and password recovery framework using the vinci console. Default username and password You can create a standard database login table using the command php vinci katrina:userAuth . This command will insert a default email and password. To authenticate, use the email solital@email.com and password solital NOTE: When creating the login structure with the command php vinci auth , the method userAuth is executed automatically, it is not necessary to execute it later.","title":"Authenticate"},{"location":"auth/#authenticate","text":"Solital uses the Guardian class to perform authentication. First of all, make sure to change the Guardian constants in config.php inside the config folder. /** * GUARDIAN CONSTANTS */ /* Login route if login verification is false */ define('URL_LOGIN', 'your_login_url'); /* Dashboard route if login verification is true */ define('URL_DASHBOARD', 'your_dashboard_url'); /* Standard Guardian index */ define('INDEX_LOGIN', 'solital_index_login');","title":"Authenticate"},{"location":"auth/#setting","text":"On your Controller, extend the AuthController class. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Controller\\Auth\\AuthController; class UserController extends AuthController { #... } To do this, define your database username and password fields, the values \u200b\u200bof your form input and the table where your username and password will be stored as shown below. $res = $this->columns('your_username_column', 'your_password_column') ->values('input_username_name', 'input_password_name') ->register('your_table'); The $res variable will return true if authentication is true. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { Message::newMessage('wrongLogin', 'Incorrect username or password'); response()->redirect('your_login_url'); } Below is an example method of authentication. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Controller\\Auth\\AuthController; class UserController extends AuthController { public function verifyLogin() { $res = $this->columns('email_column', 'pass_column') ->values('input_email', 'input_password') ->register('tb_users'); if ($res == false) { Message::newMessage('wrongLogin', 'Incorrect username or password'); response()->redirect('your_login_url'); } } }","title":"Setting"},{"location":"auth/#check-login","text":"To ensure that the user is authenticated, use checkLogin() method. If the login has not been validated using the validate() method, the user will be redirected to the route defined in the constant URL_LOGIN . The example below shows the method along with the Wolf template. Guardian::checkLogin(); Wolf::loadView('home'); To ensure that the user doesn't fall into the login route when it has already been validated, insert the checkLogged() method in your login route. This method will redirect the user to your system's dashboard. Make sure your constant URL_DASHBOARD has a defined value. Guardian::checkLogged(); Wolf::loadView('login');","title":"Check login"},{"location":"auth/#log-off","text":"To log off, use the logoff() method. Guardian::logoff();","title":"Log off"},{"location":"auth/#login-structure-and-password-recovery","text":"See here how to create a pre-assembled login and password recovery framework using the vinci console.","title":"Login structure and password recovery"},{"location":"auth/#default-username-and-password","text":"You can create a standard database login table using the command php vinci katrina:userAuth . This command will insert a default email and password. To authenticate, use the email solital@email.com and password solital NOTE: When creating the login structure with the command php vinci auth , the method userAuth is executed automatically, it is not necessary to execute it later.","title":"Default username and password"},{"location":"cache/","text":"Cache (PSR-16) Cache is a layer of high-speed physical data storage that holds a subset of data, usually temporary in nature, so that future requests for that data are answered more quickly than is possible when accessing the primary storage location of data. Caching allows you to efficiently reuse previously recovered or computed data. How to use Single cache You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\Cache; $cache = new Cache(); $list = $this->instance()->select()->build(\"all\"); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid. Mutiple cache The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\Cache; $cache = new Cache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]); Clear cache To clear the entire cache created with the Cache class, use the clear function. $cache->clear(); Wolf Template To cache a template in Wolf, use the static cache function to set the cache file time as shown below: Wolf::cache(date('Hi')); Wolf::loadView('home');","title":"Cache (PSR-16)"},{"location":"cache/#cache-psr-16","text":"Cache is a layer of high-speed physical data storage that holds a subset of data, usually temporary in nature, so that future requests for that data are answered more quickly than is possible when accessing the primary storage location of data. Caching allows you to efficiently reuse previously recovered or computed data.","title":"Cache (PSR-16)"},{"location":"cache/#how-to-use","text":"","title":"How to use"},{"location":"cache/#single-cache","text":"You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\Cache; $cache = new Cache(); $list = $this->instance()->select()->build(\"all\"); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid.","title":"Single cache"},{"location":"cache/#mutiple-cache","text":"The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\Cache; $cache = new Cache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]);","title":"Mutiple cache"},{"location":"cache/#clear-cache","text":"To clear the entire cache created with the Cache class, use the clear function. $cache->clear();","title":"Clear cache"},{"location":"cache/#wolf-template","text":"To cache a template in Wolf, use the static cache function to set the cache file time as shown below: Wolf::cache(date('Hi')); Wolf::loadView('home');","title":"Wolf Template"},{"location":"components/","text":"Components Wolf Template Wolf is Solital's standard template system. You can load any template into the resource/views folder Basic Below is the basic code to load any template: use Solital\\Core\\Wolf\\Wolf; Wolf::loadView('home'); Parameters The sitaxe below loads the parameters to be viewed in your template. Wolf::loadView('home', [ 'title' => 'My Title' ]); And in your home.php , retrieve the value informed in this way: <title>$title</title> Custom extensions Wolf will search for files in php format, but to search for a different format, use the last parameter. Wolf::loadView('home', [ 'title' => 'My Title' ], false, \"html\"); Loading CSS, JS and images Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static loadCss method in your template. <link rel=\"stylesheet\" href=\"<?= self::loadCss('style.css'); ?>\"> To load a JS file, use the static loadJs method in your template. <link rel=\"stylesheet\" href=\"<?= self::loadJs('file.js'); ?>\"> To load a image file, use the static loadImg method in your template. <img src=\"<?= self::loadImg('image.png'); ?>\"> To load a file outside the _css , _js and _img folder, use the loadFile method. <img src=\"<?= self::loadFile('path/for/your/file'); ?>\"> Cache See the cache part here to learn how to use the cache in Wolf. Message Message helps you when displaying messages in your view. Its syntax is basic as shown below. To create a new message: use Solital\\Core\\Resource\\Message; Message::new(\"your_index_message\", \"your_messsage\"); To retrieve a message: use Solital\\Core\\Resource\\Message; Message::get(\"your_index_message\"); To delete a message: use Solital\\Core\\Resource\\Message; Message::clear(\"your_index_message\"); To recover and then delete a message: use Solital\\Core\\Resource\\Message; Message::get(\"your_index_message\"); Message::clear(\"your_index_message\"); Mail Mail is a class of Solital that uses PHP's native mail to send email. Use The sitaxis below is used to be able to send basic e-mail. use Solital\\Core\\Resource\\Mail; Mail::send(\"your_sender@email.com\", \"your_recipient@email.com\", \"your_subject\", \"your_message\"); Validate To check if an email is really valid, use the validateEmail function. $res = Mail::validateEmail(\"brenno.gnr@gmail.com\"); pre($res); Optional parameters To add a reply, text type, charset and priority, use the optional parameters. Mail::send(\"your_sender@email.com\", \"your_recipient@email.com\", \"your_subject\", \"your_message\", \"your_reply@email.com\", \"type_text\", \"your_charset\", your_priority); Optional parameters have the following values by default: Reply to: (string) null Type: (string) text/plan Charset: (string) UTF-8 Priority: (int) 3","title":"Components"},{"location":"components/#components","text":"","title":"Components"},{"location":"components/#wolf-template","text":"Wolf is Solital's standard template system. You can load any template into the resource/views folder","title":"Wolf Template"},{"location":"components/#basic","text":"Below is the basic code to load any template: use Solital\\Core\\Wolf\\Wolf; Wolf::loadView('home');","title":"Basic"},{"location":"components/#parameters","text":"The sitaxe below loads the parameters to be viewed in your template. Wolf::loadView('home', [ 'title' => 'My Title' ]); And in your home.php , retrieve the value informed in this way: <title>$title</title>","title":"Parameters"},{"location":"components/#custom-extensions","text":"Wolf will search for files in php format, but to search for a different format, use the last parameter. Wolf::loadView('home', [ 'title' => 'My Title' ], false, \"html\");","title":"Custom extensions"},{"location":"components/#loading-css-js-and-images","text":"Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static loadCss method in your template. <link rel=\"stylesheet\" href=\"<?= self::loadCss('style.css'); ?>\"> To load a JS file, use the static loadJs method in your template. <link rel=\"stylesheet\" href=\"<?= self::loadJs('file.js'); ?>\"> To load a image file, use the static loadImg method in your template. <img src=\"<?= self::loadImg('image.png'); ?>\"> To load a file outside the _css , _js and _img folder, use the loadFile method. <img src=\"<?= self::loadFile('path/for/your/file'); ?>\">","title":"Loading CSS, JS and images"},{"location":"components/#cache","text":"See the cache part here to learn how to use the cache in Wolf.","title":"Cache"},{"location":"components/#message","text":"Message helps you when displaying messages in your view. Its syntax is basic as shown below. To create a new message: use Solital\\Core\\Resource\\Message; Message::new(\"your_index_message\", \"your_messsage\"); To retrieve a message: use Solital\\Core\\Resource\\Message; Message::get(\"your_index_message\"); To delete a message: use Solital\\Core\\Resource\\Message; Message::clear(\"your_index_message\"); To recover and then delete a message: use Solital\\Core\\Resource\\Message; Message::get(\"your_index_message\"); Message::clear(\"your_index_message\");","title":"Message"},{"location":"components/#mail","text":"Mail is a class of Solital that uses PHP's native mail to send email.","title":"Mail"},{"location":"components/#use","text":"The sitaxis below is used to be able to send basic e-mail. use Solital\\Core\\Resource\\Mail; Mail::send(\"your_sender@email.com\", \"your_recipient@email.com\", \"your_subject\", \"your_message\");","title":"Use"},{"location":"components/#validate","text":"To check if an email is really valid, use the validateEmail function. $res = Mail::validateEmail(\"brenno.gnr@gmail.com\"); pre($res);","title":"Validate"},{"location":"components/#optional-parameters","text":"To add a reply, text type, charset and priority, use the optional parameters. Mail::send(\"your_sender@email.com\", \"your_recipient@email.com\", \"your_subject\", \"your_message\", \"your_reply@email.com\", \"type_text\", \"your_charset\", your_priority); Optional parameters have the following values by default: Reply to: (string) null Type: (string) text/plan Charset: (string) UTF-8 Priority: (int) 3","title":"Optional parameters"},{"location":"deploy/","text":"Deploy To deploy your project made in Solital Framework, do a git pull on your hosting. Then, update all components using composer update . Solital may receive some important updates during this period of development. Apache There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain.","title":"Deploy"},{"location":"deploy/#deploy","text":"To deploy your project made in Solital Framework, do a git pull on your hosting. Then, update all components using composer update . Solital may receive some important updates during this period of development.","title":"Deploy"},{"location":"deploy/#apache","text":"There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain.","title":"Apache"},{"location":"events/","text":"Events This section will help you understand how to register your own callbacks to events in the router. It will also cover the basics of event-handlers; how to use the handlers provided with the router and how to create your own custom event-handlers. Available events This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered. EVENT_INIT - Fires when router is initializing and before routes are loaded. EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned. EVENT_ADD_ROUTE route Fires when route is added to the router. EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized. EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded. EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered. EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes. EVENT_FIND_ROUTE name Fires whenever the findRoute method is called within the Router . This usually happens when the router tries to find routes that contains a certain url, usually after the EventHandler::EVENT_GET_URL event. EVENT_GET_URL name parameters getParams Fires whenever the Router::getUrl method or url -helper function is called and the router tries to find the route. EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered. EVENT_RENDER_ROUTE route Fires before a route is rendered. EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers. EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler. EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered. EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered. - Registering new event To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler); Custom EventHandlers EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } }","title":"Events"},{"location":"events/#events","text":"This section will help you understand how to register your own callbacks to events in the router. It will also cover the basics of event-handlers; how to use the handlers provided with the router and how to create your own custom event-handlers.","title":"Events"},{"location":"events/#available-events","text":"This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered. EVENT_INIT - Fires when router is initializing and before routes are loaded. EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned. EVENT_ADD_ROUTE route Fires when route is added to the router. EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized. EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded. EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered. EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes. EVENT_FIND_ROUTE name Fires whenever the findRoute method is called within the Router . This usually happens when the router tries to find routes that contains a certain url, usually after the EventHandler::EVENT_GET_URL event. EVENT_GET_URL name parameters getParams Fires whenever the Router::getUrl method or url -helper function is called and the router tries to find the route. EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered. EVENT_RENDER_ROUTE route Fires before a route is rendered. EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers. EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler. EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered. EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered. -","title":"Available events"},{"location":"events/#registering-new-event","text":"To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler);","title":"Registering new event"},{"location":"events/#custom-eventhandlers","text":"EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } }","title":"Custom EventHandlers"},{"location":"folders-files/","text":"Handling Folders and Files You can manipulate folders and files within Solital through the HandleFiles class, such as creating folders, removing folders, listing files and deleting files. use Solital\\Core\\Resource\\HandleFiles; $folder = new HandleFiles(); List files within a folder list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $folder->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $folder->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for Check if a file exists To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $folder->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $folder->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res); Create folder To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $folder->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $folder->create(\"folder_name\", 0755); pre($res); Remove folder To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $folder->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $folder->remove(\"folder_name\", false); pre($res);","title":"Handling Folders and Files"},{"location":"folders-files/#handling-folders-and-files","text":"You can manipulate folders and files within Solital through the HandleFiles class, such as creating folders, removing folders, listing files and deleting files. use Solital\\Core\\Resource\\HandleFiles; $folder = new HandleFiles();","title":"Handling Folders and Files"},{"location":"folders-files/#list-files-within-a-folder","text":"list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $folder->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $folder->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for","title":"List files within a folder"},{"location":"folders-files/#check-if-a-file-exists","text":"To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $folder->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $folder->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res);","title":"Check if a file exists"},{"location":"folders-files/#create-folder","text":"To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $folder->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $folder->create(\"folder_name\", 0755); pre($res);","title":"Create folder"},{"location":"folders-files/#remove-folder","text":"To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $folder->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $folder->remove(\"folder_name\", false); pre($res);","title":"Remove folder"},{"location":"http/","text":"HTTP CLient Solital has a component to manipulate the HTTP client, useful for consuming API and making HTTP requests. Before, you will need to install the component using the command below: composer install solital/http-client Requirements PHP >= 7.2 (Compatible with PHP 8) CURL extension enabled Basic use To make basic use of the component, you will need to instantiate the HttpClient class. Then, call the request function, passing the method (GET, POST, ...) and the url as a parameter. Then return the data. use Solital\\HttpClient; $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res); Supported methods HttpClient supports the methods below. GET POST PUT DELETE PATCH OPTIONS Return types You can return the answer in json, array or object. The methods below show an example. $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); /** Return json */ $res = $client->toJson(); /** Return array */ $res = $client->toArray(); /** Return object */ $res = $client->toObject(); pre($res); Sending data If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values in the request method. $client = new HttpClient(); $res = $client->request(\"PUT\", \"http://api.url.com\", [ 'data' => 'your_data_values' ])->toJson(); echo $res; Custom Headers By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use an array in the constructor on the instance. $headers = [ 'Content-Type: application/pdf' ]; $client = new HttpClient($headers); #... Enabling SSL verification HttpClient by default does not perform SSL verification. To enable verification, use the enableSSL method. $client = new HttpClient(); $client->enableSSL(); #... Authentication Basic Auth To perform authentication on an API that requires basic authentication, you can use the second parameter to inform the user and password. It is necessary to inform an array containing the indexes user and pass . $client = new HttpClient(null, [ 'user' => 'username', 'pass' => '123' ]); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res); Securing routes With Basic Auth Basic authentication requires the username and password in the class constructor. If an index other than user and pass is informed, an exception will be thrown. You can protect your routes through basic authentication as shown below. use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth([ 'user' => 'username', 'pass' => '123' ]); $auth->basic(); With Digest Auth In digest authentication, it is not necessary to inform anything in the constructor, just pass the allowed users with their respective passwords as a parameter in the digest method. use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth(); # 'username' => 'password' $auth->digest(['admin' => 'pass1', 'admin2' => 'pass2', ...]);","title":"HTTP Client"},{"location":"http/#http-client","text":"Solital has a component to manipulate the HTTP client, useful for consuming API and making HTTP requests. Before, you will need to install the component using the command below: composer install solital/http-client","title":"HTTP CLient"},{"location":"http/#requirements","text":"PHP >= 7.2 (Compatible with PHP 8) CURL extension enabled","title":"Requirements"},{"location":"http/#basic-use","text":"To make basic use of the component, you will need to instantiate the HttpClient class. Then, call the request function, passing the method (GET, POST, ...) and the url as a parameter. Then return the data. use Solital\\HttpClient; $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res);","title":"Basic use"},{"location":"http/#supported-methods","text":"HttpClient supports the methods below. GET POST PUT DELETE PATCH OPTIONS","title":"Supported methods"},{"location":"http/#return-types","text":"You can return the answer in json, array or object. The methods below show an example. $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); /** Return json */ $res = $client->toJson(); /** Return array */ $res = $client->toArray(); /** Return object */ $res = $client->toObject(); pre($res);","title":"Return types"},{"location":"http/#sending-data","text":"If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values in the request method. $client = new HttpClient(); $res = $client->request(\"PUT\", \"http://api.url.com\", [ 'data' => 'your_data_values' ])->toJson(); echo $res;","title":"Sending data"},{"location":"http/#custom-headers","text":"By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use an array in the constructor on the instance. $headers = [ 'Content-Type: application/pdf' ]; $client = new HttpClient($headers); #...","title":"Custom Headers"},{"location":"http/#enabling-ssl-verification","text":"HttpClient by default does not perform SSL verification. To enable verification, use the enableSSL method. $client = new HttpClient(); $client->enableSSL(); #...","title":"Enabling SSL verification"},{"location":"http/#authentication","text":"","title":"Authentication"},{"location":"http/#basic-auth","text":"To perform authentication on an API that requires basic authentication, you can use the second parameter to inform the user and password. It is necessary to inform an array containing the indexes user and pass . $client = new HttpClient(null, [ 'user' => 'username', 'pass' => '123' ]); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res);","title":"Basic Auth"},{"location":"http/#securing-routes","text":"","title":"Securing routes"},{"location":"http/#with-basic-auth","text":"Basic authentication requires the username and password in the class constructor. If an index other than user and pass is informed, an exception will be thrown. You can protect your routes through basic authentication as shown below. use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth([ 'user' => 'username', 'pass' => '123' ]); $auth->basic();","title":"With Basic Auth"},{"location":"http/#with-digest-auth","text":"In digest authentication, it is not necessary to inform anything in the constructor, just pass the allowed users with their respective passwords as a parameter in the digest method. use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth(); # 'username' => 'password' $auth->digest(['admin' => 'pass1', 'admin2' => 'pass2', ...]);","title":"With Digest Auth"},{"location":"injection/","text":"Dependecy Container (PSR-11) Solital has implemented the PSR-11, that is, you can create containers easily and with good practices. The syntax below shows a clear example. use Solital\\Core\\Course\\Container\\Container; $container = new Container(); $container->set('user', function($args) { return new UserModel($args); }, new ContactModel()); And to retrieve a value: $dep = $container->get('user'); $dep->run(); You can also use containers within the classes. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Model\\UserModel; use Solital\\Components\\Model\\ContactModel; use Solital\\Core\\Course\\Container\\Container; class UserController { private $container; public function __construct() { $this->container = new Container(); $this->container->set(\"user\", function($args) { return new UserModel($args); }, new ContactModel()); } public function user() { $dep = $this->container->get('user'); $dep->run(); } public function container() { $dep = $this->container->get('user'); $dep->run(); } }","title":"Dependency Container (PSR-11)"},{"location":"injection/#dependecy-container-psr-11","text":"Solital has implemented the PSR-11, that is, you can create containers easily and with good practices. The syntax below shows a clear example. use Solital\\Core\\Course\\Container\\Container; $container = new Container(); $container->set('user', function($args) { return new UserModel($args); }, new ContactModel()); And to retrieve a value: $dep = $container->get('user'); $dep->run(); You can also use containers within the classes. <?php namespace Solital\\Components\\Controller; use Solital\\Components\\Model\\UserModel; use Solital\\Components\\Model\\ContactModel; use Solital\\Core\\Course\\Container\\Container; class UserController { private $container; public function __construct() { $this->container = new Container(); $this->container->set(\"user\", function($args) { return new UserModel($args); }, new ContactModel()); } public function user() { $dep = $this->container->get('user'); $dep->run(); } public function container() { $dep = $this->container->get('user'); $dep->run(); } }","title":"Dependecy Container (PSR-11)"},{"location":"input.params/","text":"Input & parameters Solital offers libraries and helpers that makes it easy to manage and manipulate input-parameters like $_POST , $_GET and $_FILE . Using the Input class to manage parameters You can use the InputHandler class to easily access and manage parameters from your request. The InputHandler class offers extended features such as copying/moving uploaded files directly on the object, getting file-extension, mime-type etc. Get single parameter value input($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. $name = input('name', 'Guest', 'post', 'get'); Get parameter object When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. $object = input()->file($index, $defaultValue = null); Managing files The UP_DIR constant is present in the config.php file. It defines the directory where your files will be stored. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> */ /* @var $image \\Solital\\Core\\Http\\Input\\InputFile */ /** * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(UP_DIR.'/fotos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> */ /* @var $image \\Solital\\Core\\Http\\Input\\InputFile */ /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(UP_DIR.'/fotos/'.$img); } Get all parameters # Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Input & params"},{"location":"input.params/#input-parameters","text":"Solital offers libraries and helpers that makes it easy to manage and manipulate input-parameters like $_POST , $_GET and $_FILE .","title":"Input &amp; parameters"},{"location":"input.params/#using-the-input-class-to-manage-parameters","text":"You can use the InputHandler class to easily access and manage parameters from your request. The InputHandler class offers extended features such as copying/moving uploaded files directly on the object, getting file-extension, mime-type etc.","title":"Using the Input class to manage parameters"},{"location":"input.params/#get-single-parameter-value","text":"input($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. $name = input('name', 'Guest', 'post', 'get');","title":"Get single parameter value"},{"location":"input.params/#get-parameter-object","text":"When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. $object = input()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. $object = input()->file($index, $defaultValue = null);","title":"Get parameter object"},{"location":"input.params/#managing-files","text":"The UP_DIR constant is present in the config.php file. It defines the directory where your files will be stored. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> */ /* @var $image \\Solital\\Core\\Http\\Input\\InputFile */ /** * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(UP_DIR.'/fotos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> */ /* @var $image \\Solital\\Core\\Http\\Input\\InputFile */ /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(UP_DIR.'/fotos/'.$img); }","title":"Managing files"},{"location":"input.params/#get-all-parameters","text":"# Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Get all parameters"},{"location":"installation/","text":"Installation Setting up Nginx If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; } Setting up Apache Nothing special is required for Apache to work. We've include the .htaccess file in the public folder. If rewriting is not working for you, please check that the mod_rewrite module (htaccess support) is enabled in the Apache configuration. Below is an example of an working .htaccess file used by Solital. Simply create a new .htaccess file in your projects public directory and paste the contents below in your newly created file. This will redirect all requests to your index.php file (see Configuration section below). RewriteEngine on RewriteCond %{SCRIPT_FILENAME} !-f RewriteCond %{SCRIPT_FILENAME} !-d RewriteCond %{SCRIPT_FILENAME} !-l RewriteRule ^(.*)$ index.php/$1 Setting up IIS On IIS you have to add some lines your web.config file in the public folder or create a new one. If rewriting is not working for you, please check that your IIS version have included the url rewrite module or download and install them from Microsoft web site. web.config example Below is an example of an working web.config file used by Solital. Simply create a new web.config file in your projects public directory and paste the contents below in your newly created file. This will redirect all requests to your index.php file (see Configuration section below). If the web.config file already exists, add the <rewrite> section inside the <system.webServer> branch. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration> <system.webServer> <rewrite> <rules> <!-- Remove slash '/' from the en of the url --> <rule name=\"RewriteRequestsToPublic\"> <match url=\"^(.*)$\" /> <conditions logicalGrouping=\"MatchAll\" trackAllCaptures=\"false\"> </conditions> <action type=\"Rewrite\" url=\"/{R:0}\" /> </rule> <!-- When requested file or folder don't exists, will request again through index.php --> <rule name=\"Imported Rule 1\" stopProcessing=\"true\"> <match url=\"^(.*)$\" ignoreCase=\"true\" /> <conditions logicalGrouping=\"MatchAll\"> <add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" /> <add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" /> </conditions> <action type=\"Rewrite\" url=\"/index.php/{R:1}\" appendQueryString=\"true\" /> </rule> </rules> </rewrite> </system.webServer> </configuration> Helper functions Below is a list of all auxiliary functions present in Solital. url(?string $name = null, $parameters = null, ?array $getParams) : Handles the URI class response() : Handles the Response class request() : Handles the Request class input($index = null, $defaultValue = null, ...$methods) : Get input class uploadFile($file) : Uploads a file serverRequest(array $headers = null, $protocol = null) : Handles the ServerRequest class redirect(string $url, ?int $code = null) : Redirect to another route csrf_token() : Get current csrf-token spoofing(string $method) : Form method spoofing pre($value) : formatted var_dump pass_hash($value, int $cost = 10) : Similar to password_hash pass_verify($value, string $hash) : Similar to password_verify remove_param() : Removes url parameters","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#setting-up-nginx","text":"If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Setting up Nginx"},{"location":"installation/#setting-up-apache","text":"Nothing special is required for Apache to work. We've include the .htaccess file in the public folder. If rewriting is not working for you, please check that the mod_rewrite module (htaccess support) is enabled in the Apache configuration. Below is an example of an working .htaccess file used by Solital. Simply create a new .htaccess file in your projects public directory and paste the contents below in your newly created file. This will redirect all requests to your index.php file (see Configuration section below). RewriteEngine on RewriteCond %{SCRIPT_FILENAME} !-f RewriteCond %{SCRIPT_FILENAME} !-d RewriteCond %{SCRIPT_FILENAME} !-l RewriteRule ^(.*)$ index.php/$1","title":"Setting up Apache"},{"location":"installation/#setting-up-iis","text":"On IIS you have to add some lines your web.config file in the public folder or create a new one. If rewriting is not working for you, please check that your IIS version have included the url rewrite module or download and install them from Microsoft web site.","title":"Setting up IIS"},{"location":"installation/#webconfig-example","text":"Below is an example of an working web.config file used by Solital. Simply create a new web.config file in your projects public directory and paste the contents below in your newly created file. This will redirect all requests to your index.php file (see Configuration section below). If the web.config file already exists, add the <rewrite> section inside the <system.webServer> branch. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration> <system.webServer> <rewrite> <rules> <!-- Remove slash '/' from the en of the url --> <rule name=\"RewriteRequestsToPublic\"> <match url=\"^(.*)$\" /> <conditions logicalGrouping=\"MatchAll\" trackAllCaptures=\"false\"> </conditions> <action type=\"Rewrite\" url=\"/{R:0}\" /> </rule> <!-- When requested file or folder don't exists, will request again through index.php --> <rule name=\"Imported Rule 1\" stopProcessing=\"true\"> <match url=\"^(.*)$\" ignoreCase=\"true\" /> <conditions logicalGrouping=\"MatchAll\"> <add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" /> <add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" /> </conditions> <action type=\"Rewrite\" url=\"/index.php/{R:1}\" appendQueryString=\"true\" /> </rule> </rules> </rewrite> </system.webServer> </configuration>","title":"web.config example"},{"location":"installation/#helper-functions","text":"Below is a list of all auxiliary functions present in Solital. url(?string $name = null, $parameters = null, ?array $getParams) : Handles the URI class response() : Handles the Response class request() : Handles the Request class input($index = null, $defaultValue = null, ...$methods) : Get input class uploadFile($file) : Uploads a file serverRequest(array $headers = null, $protocol = null) : Handles the ServerRequest class redirect(string $url, ?int $code = null) : Redirect to another route csrf_token() : Get current csrf-token spoofing(string $method) : Form method spoofing pre($value) : formatted var_dump pass_hash($value, int $cost = 10) : Similar to password_hash pass_verify($value, string $hash) : Similar to password_verify remove_param() : Removes url parameters","title":"Helper functions"},{"location":"katrina/","text":"Getting Started Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system. Requirements PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled Installation Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina Settings If you are using the Solital framework, run the php vinci katrina:configure command to configure the db.php file via Vinci ( see more about configuring Katrina ORM No Vinci here) Or edit (in Solital) the db.php file inside the config folder. define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]); Initial structure You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } Data manipulation - CRUD List To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); } Listing foreign key Inner join The innerJoin () method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); } Custom SELECT You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } Insert The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; } Update The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; } Delete The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } Force delete with foreign key In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; } Manipulating tables Create a new table The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build(); List tables To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; } List columns To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; } Alter table The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); } Adding foreign key To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #... Drop table To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); } Truncate table To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); } Procedure To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; } Pagination The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last Custom Pagination If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; } Types of data Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Katrina ORM"},{"location":"katrina/#getting-started","text":"Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system.","title":"Getting Started"},{"location":"katrina/#requirements","text":"PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled","title":"Requirements"},{"location":"katrina/#installation","text":"Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina","title":"Installation"},{"location":"katrina/#settings","text":"If you are using the Solital framework, run the php vinci katrina:configure command to configure the db.php file via Vinci ( see more about configuring Katrina ORM No Vinci here) Or edit (in Solital) the db.php file inside the config folder. define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]);","title":"Settings"},{"location":"katrina/#initial-structure","text":"You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } }","title":"Initial structure"},{"location":"katrina/#data-manipulation-crud","text":"","title":"Data manipulation - CRUD"},{"location":"katrina/#list","text":"To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); }","title":"List"},{"location":"katrina/#listing-foreign-key","text":"Inner join The innerJoin () method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); }","title":"Listing foreign key"},{"location":"katrina/#custom-select","text":"You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); }","title":"Custom SELECT"},{"location":"katrina/#insert","text":"The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; }","title":"Insert"},{"location":"katrina/#update","text":"The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; }","title":"Update"},{"location":"katrina/#delete","text":"The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } Force delete with foreign key In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; }","title":"Delete"},{"location":"katrina/#manipulating-tables","text":"","title":"Manipulating tables"},{"location":"katrina/#create-a-new-table","text":"The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build();","title":"Create a new table"},{"location":"katrina/#list-tables","text":"To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; }","title":"List tables"},{"location":"katrina/#list-columns","text":"To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; }","title":"List columns"},{"location":"katrina/#alter-table","text":"The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); }","title":"Alter table"},{"location":"katrina/#adding-foreign-key","text":"To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #...","title":"Adding foreign key"},{"location":"katrina/#drop-table","text":"To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); }","title":"Drop table"},{"location":"katrina/#truncate-table","text":"To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); }","title":"Truncate table"},{"location":"katrina/#procedure","text":"To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; }","title":"Procedure"},{"location":"katrina/#pagination","text":"The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last","title":"Pagination"},{"location":"katrina/#custom-pagination","text":"If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; }","title":"Custom Pagination"},{"location":"katrina/#types-of-data","text":"Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Types of data"},{"location":"logger/","text":"Logger (PSR-3) Logger is a powerful PSR-3 logger for PHP that is simple to use. Simplicity is achieved by providing great defaults. No options to configure! Yet flexible enough to meet most logging needs. And if your application's logging needs expand beyond what Logger provides, since it implements PSR-3, you can drop in another great PSR-3 logger like MonoLog in its place when the time comes with minimal changes. Made by markrogoyski Simple 20-Second Getting-Started Tutorial use Solital\\Core\\Resource\\Logger; $logfile = '/path/to/logfile.log'; $channel = 'events'; $logger = new Logger($logfile, $channel); $logger->info('Logger really is simple.'); That's it! Your application is logging! Extended Example use Solital\\Core\\Resource\\Logger; $logfile = '/var/log/events.log'; $channel = 'billing'; $logger = new Logger($logfile, $channel); $logger->info('Begin process that usually fails.', ['process' => 'invoicing', 'user' => $user]); try { invoiceUser($user); // This usually fails } catch (\\Exception $e) { $logger->error('Billing failure.', ['process' => 'invoicing', 'user' => $user, 'exception' => $e]); } Logger output 2017-02-13 00:35:55.426630 [info] [billing] [pid:17415] Begin process that usually fails. {\"process\":\"invoicing\",\"user\":\"bob\"} {} 2017-02-13 00:35:55.430071 [error] [billing] [pid:17415] Billing failure. {\"process\":\"invoicing\",\"user\":\"bob\"} {\"message\":\"Could not process invoice.\",\"code\":0,\"file\":\"/path/to/app.php\",\"line\":20,\"trace\":[{\"file\":\"/path/to/app.php\",\"line\":13,\"function\":\"invoiceUser\",\"args\":[\"mark\"]}]} Log Output Log lines have the following format: YYYY-mm-dd HH:ii:ss.uuuuuu [loglevel] [channel] [pid:##] Log message content {\"Optional\":\"JSON Contextual Support Data\"} {\"Optional\":\"Exception Data\"} Log lines are easily readable and parsable. Log lines are always on a single line. Fields are tab separated. Log Levels Logger has eight log level severities based on PSR Log Levels . $logger->debug('Detailed information about the application run.'); $logger->info('Informational messages about the application run.'); $logger->notice('Normal but significant events.'); $logger->warning('Information that something potentially bad has occured.'); $logger->error('Runtime error that should be monitored.'); $logger->critical('A service is unavailable or unresponsive.'); $logger->alert('The entire site is down.'); $logger->emergency('The Web site is on fire.'); By default all log levels are logged. The minimum log level can be changed in two ways: * Optional constructor parameter * Setter method at any time use Solital\\Core\\Resource\\Logger; use Psr\\Log\\LogLevel; // Optional constructor Parameter (Only error and above are logged [error, critical, alert, emergency]) $logger = new Logger($logfile, $channel, LogLevel::ERROR); // Setter method (Only warning and above are logged) $logger->setLogLevel(LogLevel::WARNING); Contextual Data Logger enables logging best practices to have general-use log messages with contextual support data to give context to the message. The second argument to a log message is an associative array of key-value pairs that will log as a JSON string, serving as the contextual support data to the log message. // Add context to a Web request. $log->info('Web request initiated', ['method' => 'GET', 'endpoint' => 'user/account', 'queryParameters' => 'id=1234']); // Add context to a disk space warning. $log->warning('Free space is below safe threshold.', ['volume' => '/var/log', 'availablePercent' => 4]); Logging Exceptions Exceptions are logged with the contextual data using the key exception and the value the exception variable. catch (\\Exception $e) { $logger->error('Something exceptional has happened', ['exception' => $e]); } Log Channels Think of channels as namespaces for log lines. If you want to have multiple loggers or applications logging to a single log file, channels are your friend. Channels can be set in two ways: * Constructor parameter * Setter method at any time use Solital\\Core\\Resource\\Logger; // Constructor Parameter $channel = 'router'; $logger = new Logger($logfile, $channel); // Setter method $logger->setChannel('database'); Debug Features Logging to STDOUT When developing, you can turn on log output to the screen (STDOUT) as a convenience. $logger->setOutput(true); $logger->debug('This will get logged to STDOUT as well as the log file.'); Dummy Logger Suppose you need a logger to meet an injected dependency during a unit test, and you don't want it to actually log anything. You can set the log level to Logger::LOG_LEVEL_NONE which won't log at any level. use Solital\\Core\\Resource\\Logger; $logger->setLogLevel(Logger::LOG_LEVEL_NONE); $logger->info('This will not log to a file.');","title":"Logger (PSR-3)"},{"location":"logger/#logger-psr-3","text":"Logger is a powerful PSR-3 logger for PHP that is simple to use. Simplicity is achieved by providing great defaults. No options to configure! Yet flexible enough to meet most logging needs. And if your application's logging needs expand beyond what Logger provides, since it implements PSR-3, you can drop in another great PSR-3 logger like MonoLog in its place when the time comes with minimal changes. Made by markrogoyski","title":"Logger (PSR-3)"},{"location":"logger/#simple-20-second-getting-started-tutorial","text":"use Solital\\Core\\Resource\\Logger; $logfile = '/path/to/logfile.log'; $channel = 'events'; $logger = new Logger($logfile, $channel); $logger->info('Logger really is simple.'); That's it! Your application is logging!","title":"Simple 20-Second Getting-Started Tutorial"},{"location":"logger/#extended-example","text":"use Solital\\Core\\Resource\\Logger; $logfile = '/var/log/events.log'; $channel = 'billing'; $logger = new Logger($logfile, $channel); $logger->info('Begin process that usually fails.', ['process' => 'invoicing', 'user' => $user]); try { invoiceUser($user); // This usually fails } catch (\\Exception $e) { $logger->error('Billing failure.', ['process' => 'invoicing', 'user' => $user, 'exception' => $e]); } Logger output 2017-02-13 00:35:55.426630 [info] [billing] [pid:17415] Begin process that usually fails. {\"process\":\"invoicing\",\"user\":\"bob\"} {} 2017-02-13 00:35:55.430071 [error] [billing] [pid:17415] Billing failure. {\"process\":\"invoicing\",\"user\":\"bob\"} {\"message\":\"Could not process invoice.\",\"code\":0,\"file\":\"/path/to/app.php\",\"line\":20,\"trace\":[{\"file\":\"/path/to/app.php\",\"line\":13,\"function\":\"invoiceUser\",\"args\":[\"mark\"]}]}","title":"Extended Example"},{"location":"logger/#log-output","text":"Log lines have the following format: YYYY-mm-dd HH:ii:ss.uuuuuu [loglevel] [channel] [pid:##] Log message content {\"Optional\":\"JSON Contextual Support Data\"} {\"Optional\":\"Exception Data\"} Log lines are easily readable and parsable. Log lines are always on a single line. Fields are tab separated.","title":"Log Output"},{"location":"logger/#log-levels","text":"Logger has eight log level severities based on PSR Log Levels . $logger->debug('Detailed information about the application run.'); $logger->info('Informational messages about the application run.'); $logger->notice('Normal but significant events.'); $logger->warning('Information that something potentially bad has occured.'); $logger->error('Runtime error that should be monitored.'); $logger->critical('A service is unavailable or unresponsive.'); $logger->alert('The entire site is down.'); $logger->emergency('The Web site is on fire.'); By default all log levels are logged. The minimum log level can be changed in two ways: * Optional constructor parameter * Setter method at any time use Solital\\Core\\Resource\\Logger; use Psr\\Log\\LogLevel; // Optional constructor Parameter (Only error and above are logged [error, critical, alert, emergency]) $logger = new Logger($logfile, $channel, LogLevel::ERROR); // Setter method (Only warning and above are logged) $logger->setLogLevel(LogLevel::WARNING);","title":"Log Levels"},{"location":"logger/#contextual-data","text":"Logger enables logging best practices to have general-use log messages with contextual support data to give context to the message. The second argument to a log message is an associative array of key-value pairs that will log as a JSON string, serving as the contextual support data to the log message. // Add context to a Web request. $log->info('Web request initiated', ['method' => 'GET', 'endpoint' => 'user/account', 'queryParameters' => 'id=1234']); // Add context to a disk space warning. $log->warning('Free space is below safe threshold.', ['volume' => '/var/log', 'availablePercent' => 4]);","title":"Contextual Data"},{"location":"logger/#logging-exceptions","text":"Exceptions are logged with the contextual data using the key exception and the value the exception variable. catch (\\Exception $e) { $logger->error('Something exceptional has happened', ['exception' => $e]); }","title":"Logging Exceptions"},{"location":"logger/#log-channels","text":"Think of channels as namespaces for log lines. If you want to have multiple loggers or applications logging to a single log file, channels are your friend. Channels can be set in two ways: * Constructor parameter * Setter method at any time use Solital\\Core\\Resource\\Logger; // Constructor Parameter $channel = 'router'; $logger = new Logger($logfile, $channel); // Setter method $logger->setChannel('database');","title":"Log Channels"},{"location":"logger/#debug-features","text":"","title":"Debug Features"},{"location":"logger/#logging-to-stdout","text":"When developing, you can turn on log output to the screen (STDOUT) as a convenience. $logger->setOutput(true); $logger->debug('This will get logged to STDOUT as well as the log file.');","title":"Logging to STDOUT"},{"location":"logger/#dummy-logger","text":"Suppose you need a logger to meet an injected dependency during a unit test, and you don't want it to actually log anything. You can set the log level to Logger::LOG_LEVEL_NONE which won't log at any level. use Solital\\Core\\Resource\\Logger; $logger->setLogLevel(Logger::LOG_LEVEL_NONE); $logger->info('This will not log to a file.');","title":"Dummy Logger"},{"location":"requisitions/","text":"Requisitions Sessions and Cookies Create session and cookie The operation of the sessions and cookies are the same. To create a session, the first parameter reports the session index or the second value of it. use Solital\\Core\\Resource\\Session; Session::new('your_index', 'your_value'); And for Cookies. use Solital\\Core\\Resource\\Cookie; Cookie::new('your_index', 'your_value', 'time', 'path'); To create an array of values in a session, pass in the third parameter the name of the session index. Session::new('index', ['id' => 1, 'name' => 'hero'], 'second_index'); Display session and cookie To display a session and cookie, use a syntax below. Session::show('your_index'); Session::show('index', 'second_index'); Cookie::show('your_index'); Check session and cookie To check if a session or cookie exists, use a sintax below. Session::has('your_index'); Session::has('index', 'second_index'); Cookie::has('your_index'); Delete session and cookie To delete a session and cookie, use a syntax below. Session::delete('your_index'); Session::delete('index', 'second_index'); Cookie::delete('your_index', 'path'); You can use destroy method to destroy all sessions. Session::destroy();","title":"Requisitions"},{"location":"requisitions/#requisitions","text":"","title":"Requisitions"},{"location":"requisitions/#sessions-and-cookies","text":"","title":"Sessions and Cookies"},{"location":"requisitions/#create-session-and-cookie","text":"The operation of the sessions and cookies are the same. To create a session, the first parameter reports the session index or the second value of it. use Solital\\Core\\Resource\\Session; Session::new('your_index', 'your_value'); And for Cookies. use Solital\\Core\\Resource\\Cookie; Cookie::new('your_index', 'your_value', 'time', 'path'); To create an array of values in a session, pass in the third parameter the name of the session index. Session::new('index', ['id' => 1, 'name' => 'hero'], 'second_index');","title":"Create session and cookie"},{"location":"requisitions/#display-session-and-cookie","text":"To display a session and cookie, use a syntax below. Session::show('your_index'); Session::show('index', 'second_index'); Cookie::show('your_index');","title":"Display session and cookie"},{"location":"requisitions/#check-session-and-cookie","text":"To check if a session or cookie exists, use a sintax below. Session::has('your_index'); Session::has('index', 'second_index'); Cookie::has('your_index');","title":"Check session and cookie"},{"location":"requisitions/#delete-session-and-cookie","text":"To delete a session and cookie, use a syntax below. Session::delete('your_index'); Session::delete('index', 'second_index'); Cookie::delete('your_index', 'path'); You can use destroy method to destroy all sessions. Session::destroy();","title":"Delete session and cookie"},{"location":"routes/","text":"Routers Basic routing Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; }); Available methods Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings); Multiple HTTP-verbs Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... }); Default Base Path This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. (Credits to MasterPuffin ) Course::setDefaultBasepath('/forum') Route parameters Required parameters You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead. Optional parameters Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; }); Regular expression constraints You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']); Regular expression route-match You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is'); Custom regex for matching parameters By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below. Example This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); }); Named routes Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile'); Generating URLs To Named Routes Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section. Router groups Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method. Middleware To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Components\\Controller\\UserController'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Or otherwise: Course::match(['get', 'post'], '/user/login', 'UserController@login')->addMiddleware('\\Solital\\Components\\Controller\\UserController:guest'); Namespaces Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller ) Note Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace }); Subdomain-routing Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); }); Route prefixes The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); }); Partial groups Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); }); Exception ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface. Error route If a given route does not exist in your routers.php file, you can redirect to another route instead of displaying the route not found error using the error () method. If true , the redirection will be done. If false , you will not be redirected. Course::error(true, '/error'); Course::get('/error', function () { echo 'error 404'; }); Using custom exception handlers This is a basic example of an ExceptionHandler implementation (please see \" Easily overwrite route about to be loaded \" for examples on how to change callback). namespace Demo\\Handlers; use Solital\\Core\\Http\\Request; use Solital\\Core\\Handlers\\ExceptionHandlerInterface; use Solital\\Core\\Exceptions\\NotFoundHttpException; class CustomExceptionHandler implements ExceptionHandlerInterface { public function handleError(Request $request, \\Exception $error): void { /* You can use the exception handler to format errors depending on the request and type. */ if ($request->getUri()->contains('/api')) { response()->json([ 'error' => $error->getMessage(), 'code' => $error->getCode(), ]); } /* The router will throw the NotFoundHttpException on 404 */ if($error instanceof NotFoundHttpException) { // Render custom 404-page $request->setRewriteCallback('PageController@notFound'); return; } throw $error; } } URL Rewriting Changing current route Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url'); Bootmanager: loading routes dynamically Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param \\Solital\\Core\\Course\\Router $router * @param \\Solital\\Core\\Http\\Request $request */ public function boot(\\Solital\\Core\\Course\\Router $router, \\Solital\\Core\\Http\\Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful . The last thing we need to do, is to add our custom boot-manager to the routes.php file. You can create as many bootmanagers as you like and easily add them in your routes.php file. Course::addBootManager(new CustomRouterRules()); Adding routes manually The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route); Extending This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } } Form Method Spoofing HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"<?= url(); ?>\"> <?= spoofing('put'); ?> <!-- other input elements here --> </form> Accessing The Current Route You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute(); Other examples You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Routes"},{"location":"routes/#routers","text":"","title":"Routers"},{"location":"routes/#basic-routing","text":"Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; });","title":"Basic routing"},{"location":"routes/#available-methods","text":"Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings);","title":"Available methods"},{"location":"routes/#multiple-http-verbs","text":"Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... });","title":"Multiple HTTP-verbs"},{"location":"routes/#default-base-path","text":"This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. (Credits to MasterPuffin ) Course::setDefaultBasepath('/forum')","title":"Default Base Path"},{"location":"routes/#route-parameters","text":"","title":"Route parameters"},{"location":"routes/#required-parameters","text":"You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead.","title":"Required parameters"},{"location":"routes/#optional-parameters","text":"Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; });","title":"Optional parameters"},{"location":"routes/#regular-expression-constraints","text":"You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);","title":"Regular expression constraints"},{"location":"routes/#regular-expression-route-match","text":"You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is');","title":"Regular expression route-match"},{"location":"routes/#custom-regex-for-matching-parameters","text":"By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below.","title":"Custom regex for matching parameters"},{"location":"routes/#example","text":"This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); });","title":"Example"},{"location":"routes/#named-routes","text":"Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile');","title":"Named routes"},{"location":"routes/#generating-urls-to-named-routes","text":"Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section.","title":"Generating URLs To Named Routes"},{"location":"routes/#router-groups","text":"Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method.","title":"Router groups"},{"location":"routes/#middleware","text":"To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Components\\Controller\\UserController'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Or otherwise: Course::match(['get', 'post'], '/user/login', 'UserController@login')->addMiddleware('\\Solital\\Components\\Controller\\UserController:guest');","title":"Middleware"},{"location":"routes/#namespaces","text":"Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller )","title":"Namespaces"},{"location":"routes/#note","text":"Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace });","title":"Note"},{"location":"routes/#subdomain-routing","text":"Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); });","title":"Subdomain-routing"},{"location":"routes/#route-prefixes","text":"The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); });","title":"Route prefixes"},{"location":"routes/#partial-groups","text":"Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); });","title":"Partial groups"},{"location":"routes/#exception","text":"ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface.","title":"Exception"},{"location":"routes/#error-route","text":"If a given route does not exist in your routers.php file, you can redirect to another route instead of displaying the route not found error using the error () method. If true , the redirection will be done. If false , you will not be redirected. Course::error(true, '/error'); Course::get('/error', function () { echo 'error 404'; });","title":"Error route"},{"location":"routes/#using-custom-exception-handlers","text":"This is a basic example of an ExceptionHandler implementation (please see \" Easily overwrite route about to be loaded \" for examples on how to change callback). namespace Demo\\Handlers; use Solital\\Core\\Http\\Request; use Solital\\Core\\Handlers\\ExceptionHandlerInterface; use Solital\\Core\\Exceptions\\NotFoundHttpException; class CustomExceptionHandler implements ExceptionHandlerInterface { public function handleError(Request $request, \\Exception $error): void { /* You can use the exception handler to format errors depending on the request and type. */ if ($request->getUri()->contains('/api')) { response()->json([ 'error' => $error->getMessage(), 'code' => $error->getCode(), ]); } /* The router will throw the NotFoundHttpException on 404 */ if($error instanceof NotFoundHttpException) { // Render custom 404-page $request->setRewriteCallback('PageController@notFound'); return; } throw $error; } }","title":"Using custom exception handlers"},{"location":"routes/#url-rewriting","text":"","title":"URL Rewriting"},{"location":"routes/#changing-current-route","text":"Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url');","title":"Changing current route"},{"location":"routes/#bootmanager-loading-routes-dynamically","text":"Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param \\Solital\\Core\\Course\\Router $router * @param \\Solital\\Core\\Http\\Request $request */ public function boot(\\Solital\\Core\\Course\\Router $router, \\Solital\\Core\\Http\\Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful . The last thing we need to do, is to add our custom boot-manager to the routes.php file. You can create as many bootmanagers as you like and easily add them in your routes.php file. Course::addBootManager(new CustomRouterRules());","title":"Bootmanager: loading routes dynamically"},{"location":"routes/#adding-routes-manually","text":"The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route);","title":"Adding routes manually"},{"location":"routes/#extending","text":"This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } }","title":"Extending"},{"location":"routes/#form-method-spoofing","text":"HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"<?= url(); ?>\"> <?= spoofing('put'); ?> <!-- other input elements here --> </form>","title":"Form Method Spoofing"},{"location":"routes/#accessing-the-current-route","text":"You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute();","title":"Accessing The Current Route"},{"location":"routes/#other-examples","text":"You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Other examples"},{"location":"security/","text":"Security Hash To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res); If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')::value(); pre($res); If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')::isValid(); pre($res); Forgot password Solital has a standard method for password recovery. For that, it is necessary to configure only the constant EMAIL in the file config.php , inserting the sender and recipient. The Reset class uses php's native mail method for sending e-mail. use Solital\\Core\\Security\\Reset; public function forgot() { $email = input()->post('email')->getValue(); (new Reset())->table('your_database_table', 'your_column_table') ->forgotPass($email, \"/your_redirect_url\", \"+20 minute\"); response()->redirect('/home'); } Instantiate the Reset class. In the table function, the first parameter should be the name of your table where users\u2019 emails are stored, and in the second parameter the column name where emails are stored, and then chain with the forgotPass method. In the forgotPass method, pass as first parameter the email you want to retrieve, and in the second the url in which the user will be redirected when clicking on the email link. The third parameter is optional, the time that the key will be valid will be defined. The default is +1 hour To validate the information by clicking on the email link, you can use the structure below: public function change($hash) { $res = Hash::decrypt($hash)::isValid(); if ($res == true) { $email = Hash::decrypt($hash)::value(); Wolf::loadView('auth.change', [ 'email' => $email, 'hash' => $hash ]); } else { response()->redirect('/home'); } } CSRF Protection Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. You can use the BaseCsrfVerifier to enable CSRF-validation on all request. If you need to disable verification for specific urls, please refer to the \"Custom CSRF-verifier\" section below. By default Solital will use the CookieTokenProvider class. This provider will store the security-token in a cookie on the clients machine. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below. Adding CSRF-verifier When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by adding the following line in your routes.php file: Course::csrfVerifier(new \\Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier()); Getting CSRF-token When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); You can also get the token directly: return Course::router()->getCsrfVerifier()->getTokenProvider()->setToken(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"<?= url(); ?>\"> <?= csrf_token(); ?> <!-- other input elements here --> </form>","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#hash","text":"To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res); If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')::value(); pre($res); If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')::isValid(); pre($res);","title":"Hash"},{"location":"security/#forgot-password","text":"Solital has a standard method for password recovery. For that, it is necessary to configure only the constant EMAIL in the file config.php , inserting the sender and recipient. The Reset class uses php's native mail method for sending e-mail. use Solital\\Core\\Security\\Reset; public function forgot() { $email = input()->post('email')->getValue(); (new Reset())->table('your_database_table', 'your_column_table') ->forgotPass($email, \"/your_redirect_url\", \"+20 minute\"); response()->redirect('/home'); } Instantiate the Reset class. In the table function, the first parameter should be the name of your table where users\u2019 emails are stored, and in the second parameter the column name where emails are stored, and then chain with the forgotPass method. In the forgotPass method, pass as first parameter the email you want to retrieve, and in the second the url in which the user will be redirected when clicking on the email link. The third parameter is optional, the time that the key will be valid will be defined. The default is +1 hour To validate the information by clicking on the email link, you can use the structure below: public function change($hash) { $res = Hash::decrypt($hash)::isValid(); if ($res == true) { $email = Hash::decrypt($hash)::value(); Wolf::loadView('auth.change', [ 'email' => $email, 'hash' => $hash ]); } else { response()->redirect('/home'); } }","title":"Forgot password"},{"location":"security/#csrf-protection","text":"Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. You can use the BaseCsrfVerifier to enable CSRF-validation on all request. If you need to disable verification for specific urls, please refer to the \"Custom CSRF-verifier\" section below. By default Solital will use the CookieTokenProvider class. This provider will store the security-token in a cookie on the clients machine. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below.","title":"CSRF Protection"},{"location":"security/#adding-csrf-verifier","text":"When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by adding the following line in your routes.php file: Course::csrfVerifier(new \\Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier());","title":"Adding CSRF-verifier"},{"location":"security/#getting-csrf-token","text":"When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); You can also get the token directly: return Course::router()->getCsrfVerifier()->getTokenProvider()->setToken(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"<?= url(); ?>\"> <?= csrf_token(); ?> <!-- other input elements here --> </form>","title":"Getting CSRF-token"},{"location":"starting/","text":"Starting Solital is a complete framework with everything you need to create high-value projects. Solital framework is based on the simple-php-router component, but with improvements in the core, in addition to having a cache, template, authentication, ORM system and its own console for creating pre-defined structures Installing via Composer To download Solital, use the command below: composer create-project solital/solital [solital_project_folder] It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; }); Running To execute the project, use the built-in PHP server or create a virtual host: php -S localhost:8000 -t public/ Requirements PHP >= 7.2 (Compatible with PHP 8) PHP JSON extension enabled PHP PDO extension enabled Features Basic routing (GET, POST, PUT, PATCH, UPDATE, DELETE) with support for custom multiple verbs. Regular Expression Constraints for parameters. Wolf template system. HTTP client manipulation. Vinci development assistant. Middleware (classes that intercepts before the route is rendered). ORM for database persistence CSRF protection. Sub-domain routing Custom boot managers to rewrite urls to \"nicer\" ones. Input manager; easily manage GET, POST and FILE values. PSR-3, PSR-11 and PSR-16.","title":"Starting"},{"location":"starting/#starting","text":"Solital is a complete framework with everything you need to create high-value projects. Solital framework is based on the simple-php-router component, but with improvements in the core, in addition to having a cache, template, authentication, ORM system and its own console for creating pre-defined structures","title":"Starting"},{"location":"starting/#installing-via-composer","text":"To download Solital, use the command below: composer create-project solital/solital [solital_project_folder] It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; });","title":"Installing via Composer"},{"location":"starting/#running","text":"To execute the project, use the built-in PHP server or create a virtual host: php -S localhost:8000 -t public/","title":"Running"},{"location":"starting/#requirements","text":"PHP >= 7.2 (Compatible with PHP 8) PHP JSON extension enabled PHP PDO extension enabled","title":"Requirements"},{"location":"starting/#features","text":"Basic routing (GET, POST, PUT, PATCH, UPDATE, DELETE) with support for custom multiple verbs. Regular Expression Constraints for parameters. Wolf template system. HTTP client manipulation. Vinci development assistant. Middleware (classes that intercepts before the route is rendered). ORM for database persistence CSRF protection. Sub-domain routing Custom boot managers to rewrite urls to \"nicer\" ones. Input manager; easily manage GET, POST and FILE values. PSR-3, PSR-11 and PSR-16.","title":"Features"},{"location":"vinci/","text":"Vinci Console Vinci Console is an auxiliary component to help create files faster, such as login structures, password recovery structures, database configuration and more. Access Vinci To access Vinci, open the terminal in your project folder and type php vinci [command] For Windows To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci about Create a component You can create a new component using the syntax below. php vinci [command]:[name_file] Example php vinci controller:UserController Command Description controller Creates a new controller model Create a new Model view Create a new view css Create a new CSS file js Create a new JavaScript file router Creates a new file for the route system - To see the complete list of commands, run php vinci show Remove a component Add the remove- command before using one of the aforementioned commands to remove a component created with Vinci. php vinci remove-controller:UserController Clearing the cache on solital To clear the entire solital cache, run the command below. php vinci cache-clear Configure database The db.php file has the necessary constants for Katrina ORM to communicate with the database. To configure the db.php file, run the command php vinci katrina:configure This command will ask for: database drive, host, database name, database user and password. Remember to enter the values in that order as shown below. Enter the drive, host, database name, username and password for your database separated by commas > mysql, localhost, db_solital, root, root If you want to create a standard user in the database, run php vinci katrina:userAuth Custom commands You can create a custom method to create your tables using the SQLCommands method. <?php namespace Solital\\Database\\Create; use Solital\\Components\\Model\\Model; use Solital\\Database\\Create\\Create; class SQLCommands extends Model { public function myTable() { # Here will be the commands for creating a table } } And in vinci, execute the method as follows: php vinci katrina:myTable Login structure To create a predefined login structure, use php vinci auth This command will create a LoginController class, templates for authentication and dashboard and predefined routes. Plus a standard user in the database. To learn more visit this link . If you want to remove this structure, use php vinci remove-auth NOTE: the command to remove the components does not remove the routes created. Recover password structure You can create a predefined password recovery framework. To do so, use the php vinci forgot command This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. To learn more visit this link . NOTE: the command to remove the components does not remove the routes created.","title":"Vinci Console"},{"location":"vinci/#vinci-console","text":"Vinci Console is an auxiliary component to help create files faster, such as login structures, password recovery structures, database configuration and more.","title":"Vinci Console"},{"location":"vinci/#access-vinci","text":"To access Vinci, open the terminal in your project folder and type php vinci [command]","title":"Access Vinci"},{"location":"vinci/#for-windows","text":"To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci about","title":"For Windows"},{"location":"vinci/#create-a-component","text":"You can create a new component using the syntax below. php vinci [command]:[name_file] Example php vinci controller:UserController Command Description controller Creates a new controller model Create a new Model view Create a new view css Create a new CSS file js Create a new JavaScript file router Creates a new file for the route system - To see the complete list of commands, run php vinci show","title":"Create a component"},{"location":"vinci/#remove-a-component","text":"Add the remove- command before using one of the aforementioned commands to remove a component created with Vinci. php vinci remove-controller:UserController","title":"Remove a component"},{"location":"vinci/#clearing-the-cache-on-solital","text":"To clear the entire solital cache, run the command below. php vinci cache-clear","title":"Clearing the cache on solital"},{"location":"vinci/#configure-database","text":"The db.php file has the necessary constants for Katrina ORM to communicate with the database. To configure the db.php file, run the command php vinci katrina:configure This command will ask for: database drive, host, database name, database user and password. Remember to enter the values in that order as shown below. Enter the drive, host, database name, username and password for your database separated by commas > mysql, localhost, db_solital, root, root If you want to create a standard user in the database, run php vinci katrina:userAuth Custom commands You can create a custom method to create your tables using the SQLCommands method. <?php namespace Solital\\Database\\Create; use Solital\\Components\\Model\\Model; use Solital\\Database\\Create\\Create; class SQLCommands extends Model { public function myTable() { # Here will be the commands for creating a table } } And in vinci, execute the method as follows: php vinci katrina:myTable","title":"Configure database"},{"location":"vinci/#login-structure","text":"To create a predefined login structure, use php vinci auth This command will create a LoginController class, templates for authentication and dashboard and predefined routes. Plus a standard user in the database. To learn more visit this link . If you want to remove this structure, use php vinci remove-auth NOTE: the command to remove the components does not remove the routes created.","title":"Login structure"},{"location":"vinci/#recover-password-structure","text":"You can create a predefined password recovery framework. To do so, use the php vinci forgot command This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. To learn more visit this link . NOTE: the command to remove the components does not remove the routes created.","title":"Recover password structure"}]}